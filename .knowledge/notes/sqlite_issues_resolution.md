# Исправление проблем с SQLite в системе обработки транзакций TON

## [2025-03-27 11:45] Устранение ошибок блокировок и SAVEPOINT

### Обнаруженные проблемы

1. **Ошибка именования SAVEPOINT**
   ```
   error: Error: SQLITE_ERROR: near "-": syntax error
   ```
   SQLite не поддерживает дефисы и другие специальные символы в именах SAVEPOINT. TypeORM по умолчанию создает имена типа "typeorm_-1", что вызывает синтаксическую ошибку.

2. **Блокировки базы данных**
   ```
   error: Error: SQLITE_BUSY: database is locked
   ```
   Возникает, когда несколько запросов одновременно пытаются изменить данные. SQLite поддерживает только один процесс записи одновременно.

### Внесенные изменения

#### 1. Исправление именования SAVEPOINT
В файле `src/database/config/database.config.ts` добавлен метод `generateSavepointName()` в класс `CustomNamingStrategy`:

```typescript
generateSavepointName(): string {
  return `savepoint_${Math.floor(Math.random() * 999999)}`;
}
```

Это гарантирует, что все имена SAVEPOINT будут безопасными для SQLite и не будут содержать дефисов.

#### 2. Настройка таймаута для блокировок
В конфигурацию SQLite добавлен параметр `busyTimeout`:

```typescript
extra: {
  busyTimeout: 3000 // 3 секунды
}
```

Это заставляет SQLite автоматически ждать до 3 секунд при обнаружении блокировки, вместо немедленного возврата ошибки.

#### 3. Улучшение механизма повторных попыток
В методах `lockTransaction`, `unlockTransaction`, `saveTransaction` и `addHistoryRecordWithRetry`:
- Увеличено количество максимальных попыток с 5 до 10
- Увеличена базовая задержка со 100мс до 300мс
- Добавлена более детальная обработка ошибок в методе `saveTransaction`
- Добавлены дополнительные логи для отслеживания ожидания

### Рекомендации по дальнейшей оптимизации

1. **Рассмотреть использование WAL-режима SQLite**
   WAL (Write-Ahead Logging) позволяет одновременно обрабатывать чтение и запись, что может снизить количество блокировок.
   
   ```typescript
   extra: {
     busyTimeout: 3000,
     journal_mode: 'WAL'
   }
   ```

2. **Настройка пула соединений**
   Ограничение количества одновременных соединений может помочь избежать конфликтов.

3. **Мониторинг длительных транзакций**
   Добавьте логирование времени выполнения транзакций, чтобы выявить слишком долгие операции, которые могут вызывать блокировки.

### Полезные ресурсы
- [SQLite Savepoints Documentation](https://sqlite.org/lang_savepoint.html)
- [Understanding SQLITE_BUSY](https://activesphere.com/blog/2018/12/24/understanding-sqlite-busy)
- [SQLite Threading Mode](https://www.sqlite.org/threadsafe.html)

## [2025-03-27 14:30] Обновление и результаты тестирования

### Реализованные улучшения

1. **Улучшенная версия метода generateSavepointName**
   ```typescript
   generateSavepointName(previousSavepoint?: string): string {
     const uuid = previousSavepoint || v4();
     return `typeorm_sp_${uuid.replace(/-/g, '_')}`;
   }
   ```
   Этот метод теперь использует UUID и заменяет все дефисы на подчеркивания, что делает имена SAVEPOINT еще более уникальными и безопасными.

2. **Расширенная настройка WAL-режима**
   ```typescript
   extra: {
     busyTimeout: 3000,          // 3 секунды на ожидание при блокировке
     journal: 'WAL',             // Write-Ahead Logging для снижения блокировок
     synchronous: 'NORMAL',      // Баланс между производительностью и надежностью
     cache: 'SHARED',            // Общий кеш для всех соединений
     'cache_size': 8000,         // 8МБ кеш для повышения производительности
     'threads': 4,               // Поддержка 4 параллельных потоков
     'read_uncommitted': 1       // Разрешать чтение незавершенных транзакций
   }
   ```

3. **Успешное решение проблемы SAVEPOINT**
   Ошибки синтаксиса SAVEPOINT больше не возникают, приложение не крэшится из-за этой проблемы.

### Оставшиеся проблемы

1. **Блокировки базы данных**
   ```
   error: Error: SQLITE_BUSY: database is locked
   ```
   Несмотря на WAL-режим и увеличенные таймауты, при высокой нагрузке продолжают появляться ошибки блокировок. Особенно при параллельной обработке нескольких транзакций.

2. **Поведение механизма повторных попыток**
   Текущий механизм повторных попыток работает корректно, увеличивая задержку от 300мс до нескольких секунд (последние попытки ожидают до 20+ секунд), но некоторые блокировки сохраняются длительное время.

### Рекомендации для дальнейшей оптимизации

1. **Оптимизация параллельных операций**
   - Кластеризация операций записи, чтобы уменьшить конкуренцию за блокировки
   - Если возможно, группирование нескольких обновлений в одну транзакцию

2. **Увеличение таймаута busyTimeout**
   ```typescript
   busyTimeout: 10000, // 10 секунд вместо 3
   ```

3. **Ограничение количества одновременных операций записи**
   - Реализация семафоров или очередей для ограничения параллельных операций записи
   - Добавление механизма приоритетов для критически важных операций

4. **Рассмотрение альтернатив**
   - Если проблемы с блокировками продолжают возникать при высокой нагрузке, может потребоваться переход на более мощные СУБД, такие как PostgreSQL
   - Для временного решения можно использовать шаблон Circuit Breaker для временного снижения нагрузки при обнаружении большого количества ошибок блокировок

### Заключение

Реализованные изменения значительно улучшили стабильность системы и устранили ошибки SAVEPOINT, однако проблемы блокировок SQLite при высокой нагрузке остаются фундаментальным ограничением этой СУБД. Для систем с высокой конкурентностью и требованиями к производительности в перспективе стоит рассмотреть миграцию на более подходящую СУБД. 